---
layout: post
title: Groovy For Comprehensions
keywords:
description:
tags:
---

I have been using Groovy and Grails for around 2 years now and was consistently frustrated at lacking some fundamental functional programming ideas.  Due to this, one of the first libraries I add in a project is Functional Java (http://functionaljava.org/).  This has proven a good match.

The primary page of functional programming in Groovy seems to be at http://groovy.codehaus.org/Functional+Programming+with+Groovy.  This inclues some basic usage of Functional Java with Groovy but I think it the library needs exposure more widely.  This will also help programmers transition to using functional programming with Java 8 lambdas.  From Functional Java I most commonly use the classes Stream, Option, Either/Validation, Functions and Tuples (Products) and the automated, specification based testing package, fj.test.  

Let's look at some example code.

Simple Functional Java Examples

The page http://groovy.codehaus.org/Functional+Programming+with+Groovy first lists some simple List processing using FJ (Functional Java) and Groovy.  This requires meta-programming to add new methods to the existing FJ classes.

<pre class="brush:groovy">

import fj.data.Stream

// some metaprogramming to make fj mesh well with Groovy
Stream.metaClass.filter = { Closure c -> delegate.filter(c as fj.F) }
Stream.metaClass.getAt = { n -> delegate.index(n) }
Stream.metaClass.getAt = { Range r -> r.collect{ delegate.index(it) } }
Stream.metaClass.asList = { delegate.toCollection().asList() }

def evens = Stream.range(0).filter{ it % 2 == 0 }
assert evens.take(5).asList() == [0, 2, 4, 6, 8]
assert (8..12).collect{ evens[it] } == [16, 18, 20, 22, 24]
assert evens[3..6] == [6, 8, 10, 12]

</pre>

Note that the code above uses the "as" keyword to reference the asType method on the Object class.

The metapgromming above begs the question as to where to call the initialisaton code from your program.  However, as of version 2.0, Groovy has a better way of adding methods to existing classes using the Groovy Extension Module mechanism.  This allows us to 
# add new methods to existing classes directly
# eliminate the type conversion using asType

Note that with the release of Groovy 2.2, the first beta of which was available 2013/07/15, Single Abstract Method Coercion (http://docs.codehaus.org/display/GroovyJSR/GEP+12+-+SAM+coercion) should further simplify interaction with libraries using functions as first-class values (e.g. FunctionalJava and Java 8).

My library to facilitate interaction with FunctionalJava is called FunctionalGroovy (of course) and can be download at https://oss.sonatype.org/content/groups/public/com/github/mperry/.  For example, putting this text in test.groovy and running from the command line using "groovy test.groovy".

<pre class="brush:groovy">

@GrabResolver('https://oss.sonatype.org/content/groups/public')
@Grab('com.github.mperry:functionalgroovy-core:0.2-SNAPSHOT')
@Grab('org.functionaljava:functionaljava:3.1')

import com.github.mperry.fg.*

1.to(5).each {
     println it
}

</pre>

Note that it appears this will not work from the GroovyConsole or the IntellijIDEA IDE due to existing  issues (likely classpath).





This allows us to add various methods to Functional Java to support 


h2. Other

The primary pain point in using a FP library is converting a Closure to the underlying abstractions representing a  function type.



