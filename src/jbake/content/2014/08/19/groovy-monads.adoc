= Groovy Monads
Mark Perry
2014-07-15
:jbake-type: post
:jbake-tags: groovy, monad, functional programming, functor, kind, higher-order type, typeclass, applicative
:jbake-status: published

In the last two posts, I have discussed how to implement functors and applicatives in Groovy.  This post discusses the related topic of monads.

Before we start, let's review the essence of the differences between these three concepts.  The primary method for functors, applicatives and monads are _map_, _apply_ and _flatMap_ respectively.

.Types used for Functor, Applicative and Monad
[width="60%",frame="topbot",options="header,footer"]
|=======
| Class | Primary Method | Argument | Argument | Result |
| Functor<T<_>> | map | T<A> | F<A, B> | T<B> |
| Applicative<T<_>> | apply | T<A> | T<F<A, B>> | T<B> |
| Monad<T<_>> | flatMap | T<A> | F<A, T<B>> | T<B> |
|=======

In the table above, I have used invalid syntax to represent the class to indicate that Functor, Applicative and Monad all take a single generic type argument.  The type argument itself takes a single type argument.  In Groovy, we make do with a lack of higher order types and represent the class without the <_> component, e.g. Functor<T> <<3>>.

We deduce that the differences between the classes in the table are:

* Functor: apply a function (_F<A, B>_) to a contextual value using _map_.
* Applicative: apply a contextual function (_T<F<A, B>>_) to a contextual value using _apply_.
* Monad: apply a function that returns a contextual value (_F<A, T<B>>_) to a contextual value using _flatMap_.

+++++
<!-- more -->
+++++

We define a Monad class containing two abstract methods _unit_ and _flatMap_.  Monad inherits from the Applicative class, in practice, the two abstract methods _unit_ and _flatMap_ are sufficient to implement Functor's _map_ method and Applicative's _pure_ and _apply_ methods.

[source,groovy,numbered]
----
@TypeChecked
abstract class Monad<M> extends Applicative<M> {
    abstract <B> M<B> unit(B b)
    abstract <A, B> M<B> flatMap(M<A> ma, F<A, M<B>> f)
    // other concrete methods omitted for clarity
}
----

As we have done previously for functors and applicatives, let's create concrete monads for _java.util.List_ and _fj.data.Option_ (we could have done similarly for _java.util.Optional_) to build intuition on how these work.

[source,groovy,numbered]
----
@TypeChecked
class ListMonad extends Monad<List> {

    @Override
    def <A> List<A> unit(A a) {
        [a]
    }

    @Override
    def <A, B> List<B> flatMap(List<A> list, F<A, List<B>> f) {
        def result = new LinkedList<B>()
        for (A a: list) {
            result.addAll(f.f(a))
        }
        result
    }
}
----

[source,groovy,numbered]
----
@TypeChecked
class OptionMonad extends Monad<Option> {

    @Override
    def <A> Option<A> unit(A a) {
        Option.some(a)
    }

    @Override
    def <A, B> Option<B> flatMap(Option<A> o, F<A, Option<B>> f) {
        o.isSome() ? f.f(o.some()) : Option.<B>none()
    }
}
----




Conclusion



== Bibliography

[bibliography]
* [[[1]]] FunctionalGroovy, https://github.com/mperry/functionalgroovy
* [[[2]]] Functors, Applicatives, And Monads In Pictures, http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
* [[[3]]] Groovy Functors, http://mperry.github.io/2014/07/01/groovy-functors.html.



